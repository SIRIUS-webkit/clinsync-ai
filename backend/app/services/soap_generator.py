"""
SOAP Note Generator Service

Generates structured clinical documentation in SOAP format:
- S (Subjective): Patient-reported symptoms and history
- O (Objective): Clinical observations, test results, image findings
- A (Assessment): Diagnosis, differential diagnoses, triage level
- P (Plan): Recommendations, follow-up actions, prescriptions

This is a key feature for clinical workflow integration.
"""

import logging
from datetime import datetime
from typing import Dict, Any, Optional, List
import json
import io

logger = logging.getLogger(__name__)


class SOAPNoteGenerator:
    """Generate SOAP notes from consultation data."""

    def __init__(self):
        self._template_version = "1.0"

    def generate_soap_note(
        self,
        patient_id: str,
        consultation_data: Dict[str, Any],
        consultation_type: str = "general",  # "chat", "video", "general"
    ) -> Dict[str, Any]:
        """
        Generate a SOAP note from consultation data.

        Args:
            patient_id: Anonymized patient identifier
            consultation_data: Data from the consultation including:
                - transcript: Voice/chat transcript
                - image_findings: Image analysis results
                - audio_analysis: Audio biomarker findings
                - skin_analysis: Derm Foundation results
                - response_text: AI response
                - triage_level: Urgency assessment
                - recommendations: Action items
            consultation_type: Type of consultation

        Returns:
            Structured SOAP note dictionary
        """
        timestamp = datetime.utcnow().isoformat() + "Z"

        # Extract data from consultation
        transcript = consultation_data.get("transcript", "")
        user_input = consultation_data.get("user_input", transcript)
        image_findings = consultation_data.get("image_result", {})
        audio_analysis = consultation_data.get("audio_analysis", {})
        skin_analysis = consultation_data.get("skin_analysis", [])
        response_text = consultation_data.get(
            "response_text", consultation_data.get("response", "")
        )
        triage_level = consultation_data.get("triage_level", "LOW")
        recommendations = consultation_data.get("recommendations", [])
        findings = consultation_data.get("findings", [])
        models_used = consultation_data.get("models_used", ["medgemma"])

        # Build SOAP components
        subjective = self._build_subjective(user_input, transcript)
        objective = self._build_objective(
            image_findings, audio_analysis, skin_analysis, models_used
        )
        assessment = self._build_assessment(
            response_text, triage_level, findings, skin_analysis
        )
        plan = self._build_plan(recommendations, triage_level)

        soap_note = {
            "note_id": f"SOAP-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{patient_id[:8]}",
            "version": self._template_version,
            "generated_at": timestamp,
            "patient_id": patient_id,
            "consultation_type": consultation_type,
            "soap": {
                "subjective": subjective,
                "objective": objective,
                "assessment": assessment,
                "plan": plan,
            },
            "metadata": {
                "triage_level": triage_level,
                "models_used": models_used,
                "ai_generated": True,
                "disclaimer": "This note was generated by ClinSync AI and should be reviewed by a healthcare professional.",
            },
        }

        logger.info("Generated SOAP note: %s", soap_note["note_id"])
        return soap_note

    def _build_subjective(self, user_input: str, transcript: str) -> Dict[str, Any]:
        """Build the Subjective section - patient-reported information."""
        chief_complaint = user_input or transcript or "Not specified"

        # Extract symptoms from text
        symptom_keywords = [
            "pain",
            "ache",
            "headache",
            "fever",
            "cough",
            "nausea",
            "dizzy",
            "tired",
            "fatigue",
            "rash",
            "itchy",
            "swelling",
            "bleeding",
            "breathing",
            "chest",
            "stomach",
        ]

        reported_symptoms = []
        text_lower = chief_complaint.lower()
        for symptom in symptom_keywords:
            if symptom in text_lower:
                reported_symptoms.append(symptom.capitalize())

        return {
            "chief_complaint": chief_complaint,
            "history_of_present_illness": chief_complaint,
            "reported_symptoms": (
                reported_symptoms if reported_symptoms else ["As described above"]
            ),
            "patient_narrative": transcript if transcript else chief_complaint,
        }

    def _build_objective(
        self,
        image_findings: Dict,
        audio_analysis: Dict,
        skin_analysis: List,
        models_used: List[str],
    ) -> Dict[str, Any]:
        """Build the Objective section - clinical observations."""
        objective = {
            "vital_signs": {
                "note": "Vital signs not captured during telehealth consultation"
            },
            "physical_examination": {},
            "diagnostic_imaging": {},
            "laboratory_results": {},
            "ai_analysis": {
                "models_used": models_used,
            },
        }

        # Image findings
        if image_findings:
            img_findings = image_findings.get("findings", [])
            if isinstance(img_findings, list) and img_findings:
                objective["diagnostic_imaging"] = {
                    "type": "Visual Analysis",
                    "findings": img_findings,
                    "confidence": image_findings.get("confidence", 0),
                    "severity": image_findings.get("severity", "not assessed"),
                }
            objective["physical_examination"]["visual_assessment"] = (
                "Image analysis performed"
                if img_findings
                else "No significant findings"
            )

        # Audio analysis
        if audio_analysis and audio_analysis.get("biomarkers"):
            biomarkers = audio_analysis["biomarkers"]
            objective["ai_analysis"]["audio_biomarkers"] = biomarkers
            if isinstance(biomarkers, dict):
                if biomarkers.get("cough"):
                    objective["physical_examination"][
                        "respiratory"
                    ] = f"Cough detected - {biomarkers['cough'].get('type', 'unclassified')}"

        # Skin analysis from Derm Foundation
        if skin_analysis:
            skin_findings = []
            for condition in skin_analysis[:3]:  # Top 3
                if isinstance(condition, dict):
                    skin_findings.append(
                        {
                            "condition": condition.get("condition", "Unknown"),
                            "confidence": condition.get("confidence", 0),
                            "severity": condition.get("severity", "Unknown"),
                        }
                    )
            if skin_findings:
                objective["physical_examination"]["dermatological"] = {
                    "findings": skin_findings,
                    "model": "Google Derm Foundation (HAI-DEF)",
                }

        return objective

    def _build_assessment(
        self,
        response_text: str,
        triage_level: str,
        findings: List,
        skin_analysis: List,
    ) -> Dict[str, Any]:
        """Build the Assessment section - clinical interpretation."""
        # Extract potential diagnoses from response
        differential_diagnoses = []

        # Add findings as differential considerations
        if findings:
            for finding in findings[:5]:
                if isinstance(finding, str) and finding:
                    differential_diagnoses.append(
                        {
                            "condition": finding,
                            "likelihood": "To be determined by physician",
                        }
                    )

        # Add skin conditions
        if skin_analysis:
            for condition in skin_analysis[:2]:
                if isinstance(condition, dict):
                    differential_diagnoses.append(
                        {
                            "condition": condition.get(
                                "condition", "Unknown skin condition"
                            ),
                            "likelihood": f"{condition.get('confidence', 0)*100:.0f}% confidence",
                        }
                    )

        return {
            "clinical_impression": (
                response_text[:500]
                if response_text
                else "Assessment pending physician review"
            ),
            "triage_level": triage_level,
            "triage_description": self._get_triage_description(triage_level),
            "differential_diagnoses": (
                differential_diagnoses
                if differential_diagnoses
                else [{"condition": "Pending clinical evaluation", "likelihood": "N/A"}]
            ),
            "ai_confidence_note": "AI-generated assessment requires physician validation",
        }

    def _build_plan(self, recommendations: List, triage_level: str) -> Dict[str, Any]:
        """Build the Plan section - treatment and follow-up."""
        # Default recommendations based on triage
        if not recommendations:
            recommendations = self._get_default_recommendations(triage_level)

        return {
            "immediate_actions": self._get_immediate_actions(triage_level),
            "recommendations": recommendations,
            "follow_up": self._get_follow_up(triage_level),
            "patient_education": [
                "Monitor symptoms and seek immediate care if condition worsens",
                "Keep this consultation summary for your medical records",
                "Share this report with your healthcare provider",
            ],
            "referrals": self._get_referrals(triage_level),
        }

    def _get_triage_description(self, level: str) -> str:
        """Get human-readable triage description."""
        descriptions = {
            "LOW": "Non-urgent - Can be managed with self-care or routine appointment",
            "MODERATE": "Semi-urgent - Should be seen within 24-48 hours",
            "HIGH": "Urgent - Requires prompt medical attention",
            "CRITICAL": "Emergency - Seek immediate emergency care",
        }
        return descriptions.get(level.upper(), "Assessment pending")

    def _get_default_recommendations(self, triage_level: str) -> List[str]:
        """Get default recommendations based on triage level."""
        if triage_level == "HIGH" or triage_level == "CRITICAL":
            return [
                "Seek immediate medical attention",
                "Go to nearest emergency room if symptoms worsen",
                "Do not drive yourself - call for assistance",
            ]
        elif triage_level == "MODERATE":
            return [
                "Schedule appointment with healthcare provider within 24-48 hours",
                "Monitor symptoms and seek care sooner if condition worsens",
                "Rest and stay hydrated",
            ]
        else:
            return [
                "Monitor symptoms at home",
                "Use over-the-counter remedies as appropriate",
                "Schedule routine appointment if symptoms persist beyond 7 days",
            ]

    def _get_immediate_actions(self, triage_level: str) -> List[str]:
        """Get immediate actions based on triage level."""
        if triage_level == "HIGH" or triage_level == "CRITICAL":
            return ["Seek emergency medical care immediately"]
        elif triage_level == "MODERATE":
            return ["Schedule appointment with healthcare provider"]
        else:
            return ["Continue self-monitoring"]

    def _get_follow_up(self, triage_level: str) -> Dict[str, str]:
        """Get follow-up recommendations."""
        if triage_level == "HIGH" or triage_level == "CRITICAL":
            return {
                "timeframe": "Immediate",
                "type": "Emergency/Urgent care",
            }
        elif triage_level == "MODERATE":
            return {
                "timeframe": "Within 24-48 hours",
                "type": "Primary care or urgent care",
            }
        else:
            return {
                "timeframe": "As needed or within 1-2 weeks if symptoms persist",
                "type": "Primary care",
            }

    def _get_referrals(self, triage_level: str) -> List[Dict[str, str]]:
        """Get referral suggestions."""
        if triage_level == "HIGH" or triage_level == "CRITICAL":
            return [{"specialty": "Emergency Medicine", "urgency": "Immediate"}]
        else:
            return [{"specialty": "Primary Care", "urgency": "Routine"}]

    def to_text(self, soap_note: Dict[str, Any]) -> str:
        """Convert SOAP note to readable text format."""
        soap = soap_note.get("soap", {})

        lines = [
            "=" * 60,
            "CLINSYNC AI - CONSULTATION SUMMARY (SOAP NOTE)",
            "=" * 60,
            "",
            f"Note ID: {soap_note.get('note_id', 'N/A')}",
            f"Generated: {soap_note.get('generated_at', 'N/A')}",
            f"Patient ID: {soap_note.get('patient_id', 'N/A')}",
            f"Consultation Type: {soap_note.get('consultation_type', 'N/A').upper()}",
            "",
            "-" * 60,
            "SUBJECTIVE (Patient-Reported)",
            "-" * 60,
        ]

        subj = soap.get("subjective", {})
        lines.append(f"Chief Complaint: {subj.get('chief_complaint', 'N/A')}")
        lines.append(
            f"Reported Symptoms: {', '.join(subj.get('reported_symptoms', []))}"
        )
        lines.append("")

        lines.extend(
            [
                "-" * 60,
                "OBJECTIVE (Clinical Observations)",
                "-" * 60,
            ]
        )

        obj = soap.get("objective", {})
        if obj.get("diagnostic_imaging", {}).get("findings"):
            lines.append("Imaging Findings:")
            for finding in obj["diagnostic_imaging"]["findings"]:
                lines.append(f"  • {finding}")

        phys_exam = obj.get("physical_examination", {})
        if phys_exam.get("dermatological"):
            lines.append("Dermatological (Derm Foundation Analysis):")
            for finding in phys_exam["dermatological"].get("findings", []):
                lines.append(
                    f"  • {finding.get('condition', 'N/A')} - {finding.get('severity', 'N/A')} severity"
                )

        lines.append(
            f"AI Models Used: {', '.join(obj.get('ai_analysis', {}).get('models_used', ['N/A']))}"
        )
        lines.append("")

        lines.extend(
            [
                "-" * 60,
                "ASSESSMENT (Clinical Interpretation)",
                "-" * 60,
            ]
        )

        assess = soap.get("assessment", {})
        lines.append(
            f"Triage Level: {assess.get('triage_level', 'N/A')} - {assess.get('triage_description', '')}"
        )
        lines.append("")
        lines.append("Clinical Impression:")
        lines.append(assess.get("clinical_impression", "N/A"))
        lines.append("")

        if assess.get("differential_diagnoses"):
            lines.append("Differential Diagnoses:")
            for dx in assess["differential_diagnoses"]:
                lines.append(
                    f"  • {dx.get('condition', 'N/A')} ({dx.get('likelihood', 'N/A')})"
                )
        lines.append("")

        lines.extend(
            [
                "-" * 60,
                "PLAN (Recommendations & Follow-up)",
                "-" * 60,
            ]
        )

        plan = soap.get("plan", {})
        lines.append("Immediate Actions:")
        for action in plan.get("immediate_actions", []):
            lines.append(f"  • {action}")
        lines.append("")

        lines.append("Recommendations:")
        for rec in plan.get("recommendations", []):
            if isinstance(rec, dict):
                lines.append(
                    f"  • {rec.get('text', rec.get('recommendation', str(rec)))}"
                )
            else:
                lines.append(f"  • {rec}")
        lines.append("")

        follow_up = plan.get("follow_up", {})
        lines.append(
            f"Follow-up: {follow_up.get('type', 'N/A')} within {follow_up.get('timeframe', 'N/A')}"
        )
        lines.append("")

        lines.append("Patient Education:")
        for edu in plan.get("patient_education", []):
            lines.append(f"  • {edu}")
        lines.append("")

        lines.extend(
            [
                "=" * 60,
                "DISCLAIMER",
                "=" * 60,
                soap_note.get("metadata", {}).get("disclaimer", ""),
                "",
                "This document is AI-generated and intended for informational purposes only.",
                "Please consult a qualified healthcare professional for medical advice.",
                "=" * 60,
            ]
        )

        return "\n".join(lines)

    def to_json(self, soap_note: Dict[str, Any], pretty: bool = True) -> str:
        """Convert SOAP note to JSON string."""
        if pretty:
            return json.dumps(soap_note, indent=2, default=str)
        return json.dumps(soap_note, default=str)


# Singleton instance
_soap_generator: Optional[SOAPNoteGenerator] = None


def get_soap_generator() -> SOAPNoteGenerator:
    """Get or create SOAP generator singleton."""
    global _soap_generator
    if _soap_generator is None:
        _soap_generator = SOAPNoteGenerator()
    return _soap_generator
